<!DOCTYPE html>
<html>
 
<head>
<title>Solar and Grid Usage</title>
    <meta charset="utf-8"/>

</head>
 
<body onload="init();" style="background-color:#848484">
<center><H2>Current Solar and Grid</H2></center>
<div id="Gauges">
<table><tbody>
     <tr><td width="100%">
     <canvas id="CanvasHousePower" width="33%" ></canvas>
     <canvas id="CanvasSolarGeneration" width="33%" ></canvas>
     <canvas id="CanvasGridUsage" width="33%" ></canvas>
     </td></tr>

     <tr><td width="100%">
     <canvas id="CanvasHouseEnergy", width="26%"></canvas>
     <canvas id="CanvasSolarEnergy", width="26%"></canvas>
     <canvas id="CanvasGridEnergy", width="26%"></canvas>
     </td></tr>

     <tr><td width="100%">
     <center><canvas id="CanvasSinkTemp"></canvas></center>
     </td></tr>
</tbody>
</table> 
</div>

<script type="text/javascript" src="yaml.js"></script>
<script type="text/javascript" src="steelseries-min.js"></script>
<script type="text/javascript" src="tween-min.js"></script>
<script type="text/javascript">
    
  var xhr = new XMLHttpRequest();
  var gridPower;
  var housePower;
  var solarGeneration;
  var sinkTemp;
  var solarEnergy;
  var houseEnergy;
  var gridEnergy;
  var loop = 1;
  var resizing = false;
  
  
  //When our page is hidden, don't continue to update over the network
  var hidden, visibilityChange; 
  if (typeof document.hidden !== "undefined") { // Opera 12.10 and Firefox 18 and later support 
      hidden = "hidden";
      visibilityChange = "visibilitychange";
  } else if (typeof document.msHidden !== "undefined") {
      hidden = "msHidden";
      visibilityChange = "msvisibilitychange";
  } else if (typeof document.webkitHidden !== "undefined") {
      hidden = "webkitHidden";
      visibilityChange = "webkitvisibilitychange";
  }
  
  //Setup our gauges
  function init() {
      var sectionsGridPower = [ steelseries.Section(-7000,0, 'rgba(0, 220, 0, 0.3)'),
                                steelseries.Section(0,10000, 'rgba(220,0,0,0.3)') ];
      var areaGridPower = [steelseries.Section(1000,10000, 'rgba(220,0,0,0.3)')];
      
      var browserWidth = getWidth();
      var gaugeSize = Math.floor(0.95*(browserWidth/3.0)); //Scale our guages to the available space
      
      gridPower = new steelseries.Radial('CanvasGridUsage', {
          gaugeType: steelseries.GaugeType.TYPE4,
          size: gaugeSize,
          minValue: -7000,
          maxValue: 10000,
          section: sectionsGridPower,
          area: areaGridPower,
          titleString: 'Grid Power',
          unitString: 'W',
          threshold: 0,
          lcdVisible: true,
          pointerType: steelseries.PointerType.TYPE15,
          thresholdVisible: false,
      });
      
      housePower = new steelseries.Radial('CanvasHousePower', {
          gaugeType: steelseries.GaugeType.TYPE4,
          size: gaugeSize,
          minValue: 0,
          maxValue: 10000,
          titleString: 'House Demand',
          unitString: 'W',
          lcdVisible: true,
          pointerType: steelseries.PointerType.TYPE15,
          thresholdVisible: false,
      });
      
      solarGeneration = new steelseries.Radial('CanvasSolarGeneration', {
          gaugeType: steelseries.GaugeType.TYPE4,
          size: gaugeSize,
          minValue: 0,
          maxValue: 7000,
          titleString: 'Solar Generation',
          unitString: 'W',
          lcdVisible: true,
          userLedBlinking: false,
          pointerType: steelseries.PointerType.TYPE15,
          thresholdVisible: false,
          threshold: 7000,
      });
      
      
      sinkTemp = new steelseries.Linear('CanvasSinkTemp', {
          gaugeType: steelseries.GaugeType.TYPE2,
          width: gaugeSize,
          height: Math.floor(gaugeSize/3),
          titleString: 'Heatsink Temperature',
          unitString: 'â„ƒ',
          threshold: 100,
          lcdVisible: false,
          minValue: -20,
          maxValue: 120,
      });
      
      solarEnergy = new steelseries.DisplaySingle('CanvasSolarEnergy', {
          width: gaugeSize,
          height: Math.floor(gaugeSize/4),
          unitString: 'kWh',
          unitStringVisible: true,
          headerString: 'Solar Generation Today',
          headerStringVisible: true,
      });
      
      houseEnergy = new steelseries.DisplaySingle('CanvasHouseEnergy', {
          width: gaugeSize,
          height:  Math.floor(gaugeSize/4),
          unitString: 'kWh',
          unitStringVisible: true,
          headerString: 'House Consumption Today',
          headerStringVisible: true,
      });
      
      gridEnergy = new steelseries.DisplaySingle('CanvasGridEnergy', {
          width: gaugeSize,
          height:  Math.floor(gaugeSize/4),
          unitString: 'kWh',
          unitStringVisible: true,
          headerString: 'Grid Usage Today',
          headerStringVisible: true,
      });

      window.addEventListener('resize', function(event){
          handleResize(event);
      });
      
      
      //var xhr = new XMLHttpRequest();
      update();   
  }


  function handleResize(e) {
      var browserWidth = getWidth();
      var gaugeSize = Math.floor(0.95*(browserWidth/3.0)); //Scale our guages to the available space

      if (resizing == true) {
          return;
      }
      resizing=true;
      //console.log("Width is ",browserWidth,"\n");
/*      gridPower.size = gaugeSize;
      housePower.size = gaugeSize;
      solarGeneration.size = gaugeSize;
      sinkTemp.width = gaugeSize;
      sinkTemp.height = Math.floor(gaugeSize/3);

      solarEnergy.width = gaugeSize;
      solarEnergy.height = Math.floor(gaugeSize/4);
      houseEnergy.width = gaugeSize;
      houseEnergy.height = Math.floor(gaugeSize/4);
      gridEnergy.width = gaugeSize;
      gridEnergy.height = Math.floor(gaugeSize/4);*/

      //forceRedraw(document.getElementById('Gauges'));
      window.location.href=window.location.href;
      resizing=false;
  }


  //Callback when visibility changes. Throws the "loop" boolean on or off
  function handleVisibilityChange() {
      if (document[hidden]) {
          loop=0;
          //console.log("Pause");
      } else {
          loop=1;
          //console.log("Unpause");
      }
  }
  
  //Get the raw data from the network calls "processRequest" with the newly acquired data
  //just loop if we're not visible
  async function update() {
      document.addEventListener(visibilityChange, handleVisibilityChange, false);
      
      while (1) {
          if (loop) {
              xhr.open("GET","http://mrf-gw.mrf.sonoma.ca.us/solar/solarmonLiveData", true);
              xhr.send();
              xhr.addEventListener("readystatechange", processRequest, false);
          }
          await sleep(2000);
      }
  }
  
  //Raw data is in YAML form. Parse it and update the gauges
  function processRequest(e) {
      if (xhr.readyState == 4 && xhr.status == 200) {
          var response = YAML.parse(xhr.responseText);
          //            alert(response);
          //            console.log(response);
          //            console.log(response.griddata.instantaneousdemand)
          gridPower.setValueAnimated(response.griddata.instantaneousdemand);
          housePower.setValueAnimated(response.housepowerusage);
          solarGeneration.setValueAnimated(response.inverterdata.ac_power);
          sinkTemp.setValueAnimated(response.inverterdata.sinktemp);
          solarEnergy.setValue(response.dailyenergy.solarkwh);
          houseEnergy.setValue(response.dailyenergy.houseusage);
          gridEnergy.setValue(response.dailyenergy.gridnet);
          
      }
  }
  
  //This is how we sleep in javascript
  function sleep(ms) {
      return new Promise(resolve=>setTimeout(resolve, ms));
      
  }
  
  //Get our window dimensions
  function getWidth() {
      return Math.max(
          document.body.scrollWidth,
          document.documentElement.scrollWidth,
          document.body.offsetWidth,
          document.documentElement.offsetWidth,
          document.documentElement.clientWidth
      );
  }
  
  function getHeight() {
      return Math.max(
          document.body.scrollHeight,
          document.documentElement.scrollHeight,
          document.body.offsetHeight,
          document.documentElement.offsetHeight,
          document.documentElement.clientHeight
      );
  }

 function forceRedraw(element) {
     var disp = element.style.display;
     element.style.display = 'none';
     var trick = element.offsetHeight;
     element.style.display = disp;
  }

  function forceRedraw2(element) {
      
    if (!element) { return; }

    var n = document.createTextNode(' ');
    var disp = element.style.display;  // don't worry about previous display style

    element.appendChild(n);
    element.style.display = 'none';

    setTimeout(function(){
        element.style.display = disp;
        n.parentNode.removeChild(n);
    },20); // you can play with this timeout to make it as short as possible
}
  
</script>
</body>
 
</html>
